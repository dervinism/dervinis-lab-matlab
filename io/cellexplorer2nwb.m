function cellexplorer2nwb(spikeData, nwbFile, options)
% cellexplorer2nwb(spikeData, nwbFile, options)
%
% Function converts spike sorting output saved in the CellExplorer
% (https://cellexplorer.org/) format (spikes.cellinfo.mat) to NWB format by
% attaching spike times timeseries data to an exisiting raw NWB file.
%
% Args:
%   spikeData.files
%   spikeData.startTimes
%   spikeData.existingUnitIDs
%   spikeData.newGlobalUnitIDs
%   nwbFile
%   someOption
%
% Returns:
%   None.
%
% Authors:
%   Martynas Dervinis (martynas.dervinis@gmail.com).

arguments
  spikeData (1,1) {mustBeA(spikeData,'struct')}
  nwbFile (1,:) {mustBeA(nwbFile,'char'),mustBeVector}
  options.someOption
end

% Load spiking data and convert it
nUnits = numel(spikeData.existingUnitIDs);
loadedFile = '';
spikesConv = struct();
for iUnit = 1:nUnits
  fileToLoad = spikeData.files{iUnit};
  if ~strcmpi(loadedFile,fileToLoad)
    load(fileToLoad); %#ok<*LOAD>
  end
  unitIndExisting = find(spikeData.existingUnitIDs(iUnit) == spikes.cluID);
  unitIndNew = spikeData.newGlobalUnitIDs(iUnit);
  if iUnit == 1 || unitIndNew > numel(spikesConv.cluID)
    spikesConv.times{unitIndNew} = spikes.times{unitIndExisting} + spikeData.startTimes(unitIndExisting);
    spikesConv.cluID{unitIndNew} = unitIndNew;
    spikesConv.maxWaveformCh1{unitIndNew} = spikeData.newGlobalUnitCh(iUnit)+1;
    spikesConv.filtWaveform{unitIndNew} = spikes.rawWaveform_all{unitIndExisting}(spikesConv.maxWaveformCh1{unitIndNew},:);
    spikesConv.labels{unitIndNew} = spikes.labels{unitIndExisting};
    spikesConv.chLabels{unitIndNew} = spikeData.chLabels{iUnit};
    spikesConv.areaLabels{unitIndNew} = spikeData.areaLabels{iUnit};
  elseif unitIndNew == numel(spikesConv.cluID)
    spikesConv.times{unitIndNew} = [spikesConv.times{unitIndNew}; ...
      spikes.times{unitIndExisting} + spikeData.startTimes(unitIndExisting)];
    spikesConv.cluID{unitIndNew} = unitIndNew;
    spikesConv.maxWaveformCh1{unitIndNew} = spikeData.newGlobalUnitCh(iUnit)+1;
    spikesConv.filtWaveform{unitIndNew} = [spikesConv.filtWaveform{unitIndNew}; ...
      spikes.rawWaveform_all{unitIndExisting}(spikesConv.maxWaveformCh1{unitIndNew},:)];
    spikesConv.labels{unitIndNew} = spikes.labels{unitIndExisting};
    spikesConv.chLabels{unitIndNew} = spikeData.chLabels{iUnit};
    spikesConv.leadLabels{unitIndNew} = spikeData.leadLabels{iUnit};
    spikesConv.areaLabels{unitIndNew} = spikeData.areaLabels{iUnit};
  else
    error('Unit IDs are not expected to decrease.');
  end
end

% Create units table
nwb = nwbRead(nwbFile);

dataDescription = 'Single unit activity';
[spike_times_vector, spike_times_index] = util.create_indexed_column( ...
  spikesConv.times, dataDescription);

nwb.units = types.core.Units( ...
  'colnames', {'cluster_id','type',... % Provide the column order. All column names have to be defined below
    'peak_channel_index','peak_channel_id',...
    'local_peak_channel_id','rel_horz_pos','rel_vert_pos',...
    'isi_violations','isolation_distance','area','lead_id',...
    'electrode_group','spike_times','spike_times_index'}, ...
  'description', 'Units table', ...
  'id', types.hdmf_common.ElementIdentifiers( ...
    'data', int64(0:numel(spikesConv.cluID) - 1)), ...
  'cluster_id', types.hdmf_common.VectorData( ...
    'data', cell2mat(spikesConv.cluID), ...
    'description', 'Unique cluster id'), ...
  'type', types.hdmf_common.VectorData( ...
    'data', spikesConv.labels, ...
    'description', 'Cluster type: unit vs mua'), ...
  'peak_channel_index', types.hdmf_common.VectorData( ...
    'data', cell2mat(metadata{:,4}), ...
    'description', 'Peak channel row index in the electrode table'), ...
  'peak_channel_id', types.hdmf_common.VectorData( ...
    'data', cell2mat(metadata{:,5}), ...
    'description', 'Unique ID of the channel with the largest cluster waveform amplitude'), ...
  'local_peak_channel_id', types.hdmf_common.VectorData( ...
    'data', cell2mat(metadata{:,6}), ...
    'description', 'Local probe channel with the largest cluster waveform amplitude'), ...
  'rel_horz_pos', types.hdmf_common.VectorData( ...
    'data', cell2mat(metadata{:,7})./1000, ...
    'description', 'Probe-relative horizontal position in mm'), ...
  'rel_vert_pos', types.hdmf_common.VectorData( ...
    'data', cell2mat(metadata{:,8})./1000, ...
    'description', 'Probe tip-relative vertical position in mm'), ...
  'isi_violations', types.hdmf_common.VectorData( ...
    'data', cell2mat(metadata{:,9}), ...
    'description', 'Interstimulus interval violations (unit quality measure)'), ...
  'isolation_distance', types.hdmf_common.VectorData( ...
    'data', cell2mat(metadata{:,10}), ...
    'description', 'Cluster isolation distance (unit quality measure)'), ...
  'area', types.hdmf_common.VectorData( ...
    'data', spikesConv.areaLabels, ...
    'description', 'Brain area where the unit is located.'), ...
  'lead_id', types.hdmf_common.VectorData( ...
    'data', spikesConv.leadLabels, ...
    'description', 'Lead id where the unit is located'), ...
  'spike_times', spike_times_vector, ...
  'spike_times_index', spike_times_index, ...
  'electrode_group', types.hdmf_common.VectorData( ...
    'data', metadata{:,13}, ...
    'description', 'Recording channel groups'), ...
  'waveform_mean', types.hdmf_common.VectorData( ...
    'data', cell2mat(waveformMeans), ...
    'description', ['Mean waveforms on the probe channel with the largest waveform amplitude. ' ...
    'MUA waveforms are excluded. The order that waveforms are stored match the order of units in the unit table.']) ...
);

% Append spike times